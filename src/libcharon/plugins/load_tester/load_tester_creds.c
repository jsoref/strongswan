/*
 * Copyright (C) 2008 Martin Willi
 * HSR Hochschule fuer Technik Rapperswil
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 */

#include "load_tester_creds.h"

#include <time.h>
#include <sys/stat.h>

#include <daemon.h>
#include <credentials/keys/shared_key.h>
#include <credentials/certificates/x509.h>
#include <utils/identification.h>

typedef struct private_load_tester_creds_t private_load_tester_creds_t;

/**
 * Private data of an load_tester_creds_t object
 */
struct private_load_tester_creds_t {
	/**
	 * Public part
	 */
	load_tester_creds_t public;

	/**
	 * Private key to create signatures
	 */
	private_key_t *private;

	/**
	 * CA certificate, to issue/verify peer certificates
	 */
	certificate_t *ca;

	/**
	 * Trusted CA certificates, including issuer CA
	 */
	linked_list_t *cas;

	/**
	 * Digest algorithm to issue certificates
	 */
	hash_algorithm_t digest;

	/**
	 * serial number to issue certificates
	 */
	uint32_t serial;

	/**
	 * Preshared key for IKE
	 */
	shared_key_t *psk;

	/**
	 * Password for EAP
	 */
	shared_key_t *pwd;

	/**
	 * List of certificate distribution points to include in generated certs
	 */
	linked_list_t *cdps;
};

/**
 * 1024-bit RSA key:
-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDQXr7poAPYZLxmTCqR51STGRuk9Hc5SWtTcs6b2RzpnP8EVRLx
JEVxOKE9Mw6n7mD1pNrupCpnpGRdLAV5VznTPhSQ6k7ppJJrxosRYg0pHTZqBUEC
7nQFwAe10g8q0UnM1wa4lJzGxDH78d21cVweJgbkxAeyriS0jhNs7gO5nQIDAQAB
AoGACVACtkxJf7VY2jWTPXwaQoy/uIqYfX3zhwI9i6eTbDlxCE+JDi/xzpKaWjLa
99RmjvP0OPArWQB239ck03x7gAm2obutosGbqbKzJZS5cyIayzyW9djZDHBdt9Ho
quKB39aspWit3xPzkrr+QeIkiggtmBKALTBxTwxAU+P6euECQQD4IPdrzKbCrO79
LKvoPrQQtTjL6ogag9rI9n2ZuoK3/XVybh2byOXT8tA5G5jSz9Ac8XeVOsnH9gT5
3WXeaLOFAkEA1vrm/hVSEasp5eATgQ7ig9CF+GGKqhTwXp/uOSl/h3IRmStu5J0C
9AkYyx0bn3j5R8iUEX/C00KSE1kQNh4NOQJAVOsLYlRG2idPH0xThQc4nuM2jes1
K0Xm8ZISSDNhm1BeCoyPC4rExTW7d1/vfG5svgsRrvvQpOOYrl7MB0Lz9QJBALhg
AWJiyLsskEd90Vx7dpvUaEHo7jMGuEx/X6GYzK5Oj3dNP9NEMfc4IhJ5SWqRJ0KA
bTVA3MexLXT4iqXPSkkCQQDSjLhBwvEnSuW4ElIMzBwLbu7573z2gzU82Mj6trrw
Osoox/vmcepT1Wjy4AvPZHgxp7vEXNSeS+M5L29QNTp8
-----END RSA PRIVATE KEY-----
 */
static char private[] = {
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,
};

/**
 * And an associated self-signed CA certificate (note that the keyUsage
 * extension has the digitalSignature bit set, which is not usually the case for
 * CA certificates, so it can be used as end-entity certificate in load tests).
-----BEGIN CERTIFICATE-----
MIICJjCCAY+gAwIBAgIBADANBgkqhkiG9w0BAQsFADA3MQwwCgYDVQQDEwNzcnYx
EjAQBgNVBAsTCWxvYWQtdGVzdDETMBEGA1UEChMKc3Ryb25nU3dhbjAeFw0xOTAy
MDgwODUyMjVaFw0yOTAyMDgwODUyMjVaMDcxDDAKBgNVBAMTA3NydjESMBAGA1UE
CxMJbG9hZC10ZXN0MRMwEQYDVQQKEwpzdHJvbmdTd2FuMIGfMA0GCSqGSIb3DQEB
AQUAA4GNADCBiQKBgQDQXr7poAPYZLxmTCqR51STGRuk9Hc5SWtTcs6b2RzpnP8E
VRLxJEVxOKE9Mw6n7mD1pNrupCpnpGRdLAV5VznTPhSQ6k7ppJJrxosRYg0pHTZq
BUEC7nQFwAe10g8q0UnM1wa4lJzGxDH78d21cVweJgbkxAeyriS0jhNs7gO5nQID
AQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4E
FgQUytOG/alLWTyyO6ElA3cGwIzkofYwDQYJKoZIhvcNAQELBQADgYEAIdCzmJAw
Cj6VaDacc7yOhZK61nGzNJml5NEeLzZkGzYvsIggL/Kb2v42fKYC5OunkZ1Nw3YY
207LR7wrhS7pndHfRMny86RwJ4d6LmiwtgbzTAbm3HL/iENDiyiJfCTknTvzMj9O
kGfz0rGDkJqIxx0inxp84PWWR5lX84A9pNQ=
-----END CERTIFICATE-----
 */
static char default_cert[] = {
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
};

/**
 * Default IKE preshared key
 */
static char *default_psk = "default-psk";

/**
 * Default EAP password for EAP
 */
static char *default_pwd = "default-pwd";


/**
 * Load the private key, hard-coded or from a file
 */
static private_key_t *load_issuer_key()
{
	char *path;

	path = lib->settings->get_str(lib->settings,
						"%s.plugins.load-tester.issuer_key", NULL, lib->ns);
	if (!path)
	{
		return lib->creds->create(lib->creds, CRED_PRIVATE_KEY, KEY_RSA,
					BUILD_BLOB_ASN1_DER, chunk_create(private, sizeof(private)),
					BUILD_END);
	}
	DBG1(DBG_CFG, "loading load-tester private key from '%s'", path);
	return lib->creds->create(lib->creds, CRED_PRIVATE_KEY, KEY_RSA,
					BUILD_FROM_FILE, path, BUILD_END);
}

/**
 * Load the issuing certificate, hard-coded or from a file
 */
static certificate_t *load_issuer_cert()
{
	char *path;

	path = lib->settings->get_str(lib->settings,
						"%s.plugins.load-tester.issuer_cert", NULL, lib->ns);
	if (!path)
	{
		return lib->creds->create(lib->creds, CRED_CERTIFICATE, CERT_X509,
					BUILD_BLOB_ASN1_DER,
					chunk_create(default_cert, sizeof(default_cert)),
					BUILD_X509_FLAG, X509_CA,
					BUILD_END);
	}
	DBG1(DBG_CFG, "loading load-tester issuer cert from '%s'", path);
	return lib->creds->create(lib->creds, CRED_CERTIFICATE, CERT_X509,
					BUILD_FROM_FILE, path, BUILD_END);
}

/**
 * Load (intermediate) CA certificates, hard-coded or from a file
 */
static void load_ca_certs(private_load_tester_creds_t *this)
{
	enumerator_t *enumerator;
	certificate_t *cert;
	struct stat st;
	char *path;

	path = lib->settings->get_str(lib->settings,
							"%s.plugins.load-tester.ca_dir", NULL, lib->ns);
	if (path)
	{
		enumerator = enumerator_create_directory(path);
		if (enumerator)
		{
			while (enumerator->enumerate(enumerator, NULL, &path, &st))
			{
				if (S_ISREG(st.st_mode))
				{
					DBG1(DBG_CFG, "loading load-tester CA cert from '%s'", path);
					cert = lib->creds->create(lib->creds,
											CRED_CERTIFICATE, CERT_X509,
											BUILD_FROM_FILE, path, BUILD_END);
					if (cert)
					{
						this->cas->insert_last(this->cas, cert);
					}
				}
			}
			enumerator->destroy(enumerator);
		}
	}
}

METHOD(credential_set_t, create_private_enumerator, enumerator_t*,
	private_load_tester_creds_t *this, key_type_t type, identification_t *id)
{
	if (this->private == NULL)
	{
		return NULL;
	}
	if (type != KEY_ANY && type != KEY_RSA)
	{
		return NULL;
	}
	if (id)
	{
		if (!this->private->has_fingerprint(this->private, id->get_encoding(id)))
		{
			return NULL;
		}
	}
	return enumerator_create_single(this->private, NULL);
}

METHOD(credential_set_t, create_cert_enumerator, enumerator_t*,
	private_load_tester_creds_t *this, certificate_type_t cert, key_type_t key,
	identification_t *id, bool trusted)
{
	enumerator_t *enumerator;
	certificate_t *peer_cert, *ca_cert;
	public_key_t *peer_key, *ca_key;
	identification_t *dn = NULL;
	linked_list_t *sans;
	char buf[128];
	uint32_t serial;
	time_t now;

	if (this->ca == NULL)
	{
		return NULL;
	}
	if (cert != CERT_ANY && cert != CERT_X509)
	{
		return NULL;
	}
	if (key != KEY_ANY && key != KEY_RSA)
	{
		return NULL;
	}
	if (!id)
	{
		return this->cas->create_enumerator(this->cas);
	}
	ca_key = this->ca->get_public_key(this->ca);
	if (ca_key)
	{
		if (ca_key->has_fingerprint(ca_key, id->get_encoding(id)))
		{
			ca_key->destroy(ca_key);
			return enumerator_create_single(this->ca, NULL);
		}
		ca_key->destroy(ca_key);
	}
	enumerator = this->cas->create_enumerator(this->cas);
	while (enumerator->enumerate(enumerator, &ca_cert))
	{
		if (ca_cert->has_subject(ca_cert, id))
		{
			enumerator->destroy(enumerator);
			return enumerator_create_single(ca_cert, NULL);
		}
	}
	enumerator->destroy(enumerator);

	if (!trusted && this->private)
	{
		/* peer certificate, generate on demand */
		serial = htonl(++this->serial);
		now = time(NULL);
		sans = linked_list_create();

		switch (id->get_type(id))
		{
			case ID_DER_ASN1_DN:
				break;
			case ID_FQDN:
			case ID_RFC822_ADDR:
			case ID_IPV4_ADDR:
			case ID_IPV6_ADDR:
				/* encode as subjectAltName, construct a sane DN */
				sans->insert_last(sans, id);
				snprintf(buf, sizeof(buf), "CN=%Y", id);
				dn = identification_create_from_string(buf);
				break;
			default:
				sans->destroy(sans);
				return NULL;
		}
		peer_key = this->private->get_public_key(this->private);
		peer_cert = lib->creds->create(lib->creds, CRED_CERTIFICATE, CERT_X509,
									BUILD_SIGNING_KEY, this->private,
									BUILD_SIGNING_CERT, this->ca,
									BUILD_DIGEST_ALG, this->digest,
									BUILD_PUBLIC_KEY, peer_key,
									BUILD_SUBJECT, dn ?: id,
									BUILD_SUBJECT_ALTNAMES, sans,
									BUILD_NOT_BEFORE_TIME, now - 60 * 60 * 24,
									BUILD_NOT_AFTER_TIME, now + 60 * 60 * 24,
									BUILD_SERIAL, chunk_from_thing(serial),
									BUILD_CRL_DISTRIBUTION_POINTS, this->cdps,
									BUILD_END);
		peer_key->destroy(peer_key);
		sans->destroy(sans);
		DESTROY_IF(dn);
		if (peer_cert)
		{
			return enumerator_create_single(peer_cert, (void*)peer_cert->destroy);
		}
	}
	return NULL;
}

CALLBACK(shared_filter, bool,
	void *null, enumerator_t *orig, va_list args)
{
	shared_key_t *key, **out;
	id_match_t *me, *other;

	VA_ARGS_VGET(args, out, me, other);

	if (orig->enumerate(orig, &key))
	{
		*out = key;
		if (me)
		{
			*me = ID_MATCH_ANY;
		}
		if (other)
		{
			*other = ID_MATCH_ANY;
		}
		return TRUE;
	}
	return FALSE;
}

METHOD(credential_set_t, create_shared_enumerator, enumerator_t*,
	private_load_tester_creds_t *this, shared_key_type_t type,
	identification_t *me, identification_t *other)
{
	shared_key_t *shared;

	switch (type)
	{
		case SHARED_IKE:
			shared = this->psk;
			break;
		case SHARED_EAP:
			shared = this->pwd;
			break;
		default:
			return NULL;
	}
	return enumerator_create_filter(enumerator_create_single(shared, NULL),
									shared_filter, NULL, NULL);
}

METHOD(load_tester_creds_t, destroy, void,
	private_load_tester_creds_t *this)
{
	this->cas->destroy_offset(this->cas, offsetof(certificate_t, destroy));
	DESTROY_IF(this->private);
	DESTROY_IF(this->ca);
	this->psk->destroy(this->psk);
	this->pwd->destroy(this->pwd);
	this->cdps->destroy_function(this->cdps, free);
	free(this);
}

load_tester_creds_t *load_tester_creds_create()
{
	private_load_tester_creds_t *this;
	char *pwd, *psk, *digest, *crl;

	psk = lib->settings->get_str(lib->settings,
				"%s.plugins.load-tester.preshared_key", default_psk, lib->ns);
	pwd = lib->settings->get_str(lib->settings,
				"%s.plugins.load-tester.eap_password", default_pwd, lib->ns);
	digest = lib->settings->get_str(lib->settings,
				"%s.plugins.load-tester.digest", "sha1", lib->ns);
	crl = lib->settings->get_str(lib->settings,
				"%s.plugins.load-tester.crl", NULL, lib->ns);

	INIT(this,
		.public = {
			.credential_set = {
				.create_shared_enumerator = _create_shared_enumerator,
				.create_private_enumerator = _create_private_enumerator,
				.create_cert_enumerator = _create_cert_enumerator,
				.create_cdp_enumerator = (void*)return_null,
				.cache_cert = (void*)nop,
			},
			.destroy = _destroy,
		},
		.private = load_issuer_key(),
		.ca = load_issuer_cert(),
		.cas = linked_list_create(),
		.cdps = linked_list_create(),
		.psk = shared_key_create(SHARED_IKE,
								 chunk_clone(chunk_create(psk, strlen(psk)))),
		.pwd = shared_key_create(SHARED_EAP,
								 chunk_clone(chunk_create(pwd, strlen(pwd)))),
	);

	if (this->ca)
	{
		this->cas->insert_last(this->cas, this->ca->get_ref(this->ca));
	}

	if (!enum_from_name(hash_algorithm_short_names, digest, &this->digest))
	{
		DBG1(DBG_CFG, "invalid load-tester digest: '%s', using sha1", digest);
		this->digest = HASH_SHA1;
	}

	if (crl)
	{
		x509_cdp_t *cdp;

		INIT(cdp,
			.uri = crl,
		);
		this->cdps->insert_last(this->cdps, cdp);
	}

	load_ca_certs(this);

	return &this->public;
}
