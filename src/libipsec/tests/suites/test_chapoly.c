/*
 * Copyright (C) 2015 Martin Willi
 * Copyright (C) 2015 revosec AG
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 */

#include <test_suite.h>

#include <ip_packet.h>
#include <esp_packet.h>

static iv_gen_t *ivgen;

METHOD(aead_t, get_iv_gen, iv_gen_t*,
	aead_t *this)
{
	return ivgen;
}

METHOD(iv_gen_t, get_iv, bool,
	iv_gen_t *this, uint64_t seq, size_t size, uint8_t *buffer)
{
	if (size != 8)
	{
		return FALSE;
	}
	memcpy(buffer, "\x10\x11\x12\x13\x14\x15\x16\x17", 8);
	return TRUE;
}

METHOD(iv_gen_t, allocate_iv, bool,
	iv_gen_t *this, uint64_t seq, size_t size, chunk_t *chunk)
{
	if (size != 8)
	{
		return FALSE;
	}
	*chunk = chunk_alloc(size);
	return get_iv(this, seq, chunk->len, chunk->ptr);
}

/**
 * Appendix A draft-ietf-ipsecme-chacha20-poly1305-06
 */
START_TEST(test_chapoly)
{
	host_t *src, *dst;
	ip_packet_t *icmp;
	esp_packet_t *esp;
	esp_context_t *ctx;
	chunk_t data, exp;
	uint32_t seq = 0;

	icmp = ip_packet_create(chunk_clone(chunk_from_chars(
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF)));
	ck_assert(icmp);

	src = host_create_from_string("203.0.113.153", 0);
	dst = host_create_from_string("203.0.113.5", 0);
	esp = esp_packet_create_from_payload(src, dst, icmp);

	ctx = esp_context_create(ENCR_CHACHA20_POLY1305, chunk_from_chars(
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
								0xFF,0xFF,0xFF,0xFF),
							 AUTH_UNDEFINED, chunk_empty, FALSE);
	while (seq != 4)
	{
		ck_assert(ctx->next_seqno(ctx, &seq));
	}
	INIT(ivgen,
		.get_iv = _get_iv,
		.allocate_iv = _allocate_iv,
		.destroy = (void*)free,
	);
	ctx->get_aead(ctx)->get_iv_gen = _get_iv_gen;
	ck_assert(esp->encrypt(esp, ctx, htonl(0xFF)) == SUCCESS);

	data = esp->packet.get_data(&esp->packet);
	exp = chunk_from_chars(0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
						   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
	ck_assert_msg(chunk_equals(data, exp), "got %B\nexp %B", &data, &exp);

	esp->destroy(esp);
	ctx->destroy(ctx);
	ivgen->destroy(ivgen);
}
END_TEST

Suite *chapoly_suite_create()
{
	Suite *s;
	TCase *tc;

	s = suite_create("chapoly");

	tc = tcase_create("ChaCha20Poly1305 ESP encryption");
	tcase_add_test(tc, test_chapoly);
	suite_add_tcase(s, tc);

	return s;
}
